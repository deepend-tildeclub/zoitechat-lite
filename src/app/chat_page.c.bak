#include "chat_page.h"
#include <stdarg.h>
#include <string.h>
#include <time.h>

struct _ChatPage {
  gchar *target;
  gboolean is_channel;

  GtkWidget *root;
  GtkWidget *paned;

  GtkWidget *left;
  GtkWidget *scroll;
  GtkWidget *view;
  GtkTextBuffer *buffer;

  GtkWidget *entry_wrap;
  GtkWidget *entry;

  GtkWidget *user_box;
  GtkWidget *user_label;
  GtkWidget *user_scroll;
  GtkWidget *user_view;
  GtkListStore *user_store;
};

static gboolean is_channel_target(const gchar *t) {
  if (!t || !*t) return FALSE;
  switch (t[0]) { case '#': case '&': case '!': case '+': return TRUE; default: return FALSE; }
}

static gchar *timestamp_now(void) {
  time_t now = time(NULL);
  struct tm tmv;
#if defined(_WIN32)
  localtime_s(&tmv, &now);
#else
  localtime_r(&now, &tmv);
#endif
  gchar buf[32];
  strftime(buf, sizeof(buf), "[%H:%M] ", &tmv);
  return g_strdup(buf);
}

ChatPage *chat_page_new(const gchar *target) {
  ChatPage *p = g_new0(ChatPage, 1);
  p->target = g_strdup(target && *target ? target : "status");
  p->is_channel = is_channel_target(p->target);

  p->paned = gtk_paned_new(GTK_ORIENTATION_HORIZONTAL);
  p->root = p->paned;

  p->left = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);
  gtk_widget_set_hexpand(p->left, TRUE);
  gtk_widget_set_vexpand(p->left, TRUE);
  gtk_paned_pack1(GTK_PANED(p->paned), p->left, TRUE, FALSE);

  p->scroll = gtk_scrolled_window_new(NULL, NULL);
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(p->scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
  gtk_widget_set_vexpand(p->scroll, TRUE);
  gtk_box_pack_start(GTK_BOX(p->left), p->scroll, TRUE, TRUE, 0);

  p->view = gtk_text_view_new();
  gtk_text_view_set_editable(GTK_TEXT_VIEW(p->view), FALSE);
  gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(p->view), FALSE);
  gtk_text_view_set_monospace(GTK_TEXT_VIEW(p->view), TRUE);
  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(p->view), GTK_WRAP_WORD_CHAR);
  gtk_container_add(GTK_CONTAINER(p->scroll), p->view);

  p->buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(p->view));

  p->entry_wrap = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
  gtk_style_context_add_class(gtk_widget_get_style_context(p->entry_wrap), "zc-entry");
  gtk_box_pack_end(GTK_BOX(p->left), p->entry_wrap, FALSE, FALSE, 0);

  p->entry = gtk_entry_new();
  gtk_entry_set_placeholder_text(GTK_ENTRY(p->entry), "Type message or /commandâ€¦");
  gtk_container_add(GTK_CONTAINER(p->entry_wrap), p->entry);

  /* User list */
  p->user_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
  gtk_style_context_add_class(gtk_widget_get_style_context(p->user_box), "zc-userlist");
  gtk_widget_set_size_request(p->user_box, 220, -1);
  gtk_paned_pack2(GTK_PANED(p->paned), p->user_box, FALSE, FALSE);

  p->user_label = gtk_label_new("Users");
  gtk_widget_set_halign(p->user_label, GTK_ALIGN_START);
  gtk_style_context_add_class(gtk_widget_get_style_context(p->user_label), "zc-muted");
  gtk_box_pack_start(GTK_BOX(p->user_box), p->user_label, FALSE, FALSE, 6);

  p->user_scroll = gtk_scrolled_window_new(NULL, NULL);
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(p->user_scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
  gtk_widget_set_vexpand(p->user_scroll, TRUE);
  gtk_box_pack_start(GTK_BOX(p->user_box), p->user_scroll, TRUE, TRUE, 0);

  p->user_store = gtk_list_store_new(2, G_TYPE_STRING, G_TYPE_STRING); /* display, sortkey */
  p->user_view = gtk_tree_view_new_with_model(GTK_TREE_MODEL(p->user_store));
  gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(p->user_view), FALSE);

  GtkCellRenderer *cr = gtk_cell_renderer_text_new();
  GtkTreeViewColumn *col = gtk_tree_view_column_new_with_attributes("User", cr, "text", 0, NULL);
  gtk_tree_view_append_column(GTK_TREE_VIEW(p->user_view), col);
  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(p->user_store), 1, GTK_SORT_ASCENDING);

  gtk_container_add(GTK_CONTAINER(p->user_scroll), p->user_view);

  if (!p->is_channel) gtk_widget_hide(p->user_box);
  else gtk_paned_set_position(GTK_PANED(p->paned), 740);

  gtk_style_context_add_class(gtk_widget_get_style_context(p->view), "zc-chatview");

  return p;
}

void chat_page_free(ChatPage *page) {
  if (!page) return;
  g_free(page->target);
  if (page->user_store) g_object_unref(page->user_store);
  g_free(page);
}

GtkWidget *chat_page_get_root(ChatPage *page) { return page ? page->root : NULL; }
const gchar *chat_page_get_target(ChatPage *page) { return page ? page->target : "status"; }
GtkWidget *chat_page_get_entry(ChatPage *page) { return page ? page->entry : NULL; }

static void append_with_ts(ChatPage *page, const gchar *line) {
  if (!page || !line) return;
  gchar *ts = timestamp_now();
  gchar *full = g_strconcat(ts, line, "\n", NULL);
  g_free(ts);

  GtkTextIter end;
  gtk_text_buffer_get_end_iter(page->buffer, &end);
  gtk_text_buffer_insert(page->buffer, &end, full, -1);
  gtk_text_buffer_get_end_iter(page->buffer, &end);
  gtk_text_view_scroll_to_iter(GTK_TEXT_VIEW(page->view), &end, 0.0, FALSE, 0, 0);

  g_free(full);
}

void chat_page_append(ChatPage *page, const gchar *line) { append_with_ts(page, line ? line : ""); }

void chat_page_append_fmt(ChatPage *page, const gchar *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  gchar *s = g_strdup_vprintf(fmt, ap);
  va_end(ap);
  chat_page_append(page, s);
  g_free(s);
}

static gchar *sortkey_from_display(const gchar *display) {
  if (!display) return g_strdup("");
  const gchar *p = display;
  while (*p && strchr("~&@%+", *p)) p++;
  return g_ascii_strdown(p, -1);
}

void chat_page_set_userlist(ChatPage *page, const gchar * const *display_names, gsize n) {
  if (!page || !page->is_channel) return;
  gtk_list_store_clear(page->user_store);

  for (gsize i = 0; i < n; i++) {
    const gchar *disp = display_names[i];
    if (!disp || !*disp) continue;
    GtkTreeIter it;
    gtk_list_store_append(page->user_store, &it);
    gchar *sk = sortkey_from_display(disp);
    gtk_list_store_set(page->user_store, &it, 0, disp, 1, sk, -1);
    g_free(sk);
  }

  gchar *lbl = g_strdup_printf("Users (%" G_GSIZE_FORMAT ")", n);
  gtk_label_set_text(GTK_LABEL(page->user_label), lbl);
  g_free(lbl);
}

void chat_page_clear_userlist(ChatPage *page) {
  if (!page || !page->is_channel) return;
  gtk_list_store_clear(page->user_store);
  gtk_label_set_text(GTK_LABEL(page->user_label), "Users");
}
